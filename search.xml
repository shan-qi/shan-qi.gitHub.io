<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Servlet Cookies]]></title>
    <url>%2F2018%2F07%2F14%2FServlet%20Cookies%2F</url>
    <content type="text"><![CDATA[数据来源于网络，仅供平时查询使用 Servlet CookiesCookie是在多个客户端请求之间持久存储的一小段信息。 Cookie具有名称，单个值和可选属性，例如注释，路径和域限定符，生存周期和版本号。 Cookie工作原理默认情况下，每个请求都被视为新的请求。在cookie技术中，servlet响应可以添加cookie。 所以cookie存储在浏览器的缓存中。之后，如果用户发出请求，默认情况下会带上cookie。 因此，我们就可以知道用户旧用户。 Cookie类型Servlet中有2种类型的Cookie。 非持久性cookie 持久性Cookie 非持久性cookie 它仅适用于单个会话。当用户关闭浏览器时都会删除它。 持久性Cookie 它对多个会话有效。当用户关闭浏览器时也不会删除它。只有在用户注销或注销时才被删除。 Cookie的优点 维持状态最简单的技术。 Cookie在客户端维护。 Cookie的缺点 如果从浏览器中禁用Cookie，则无法正常工作。 只能在Cookie对象中设置文本信息。 Servlet Cookie的应用示例在这个例子中，我们将用户名称(username)存储在cookie对象中，并在另一个servlet中访问它，会话对应于特定用户。所以如果从多个浏览器访问指定cookie名称，那么将得到不同的值。 打开Eclipse，创建一个动态Web项目：CookieServlet，其完整的项目结构如下 - 以下是几个主要代码文件。 文件：index.html - 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Cookies In Servlet&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div style="text-align:center;"&gt; &lt;form action="servlet1" method="post"&gt; 用户名：&lt;input type="text" name="username" value="xiao'qi"/&gt;&lt;input type="submit" value="提交" /&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 文件：FirstServlet.java - 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.xq.Cookie;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet implementation class FirstServlet */@WebServlet("/FirstServlet")public class FirstServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public FirstServlet() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; try &#123; response.setCharacterEncoding("UTF-8"); response.setContentType("text/html"); PrintWriter out = response.getWriter(); String name = request.getParameter("username"); String username = new String(name.getBytes("ISO-8859-1"),"utf-8"); out.print("&lt;!DOCTYPE html&gt;\r\n" + "&lt;html&gt;\r\n" + "&lt;head&gt;\r\n" + "&lt;meta charset=\"UTF-8\"&gt;&lt;body&gt;"); out.print("欢迎您, " + username); Cookie ck = new Cookie("uname", username);// creating cookie object response.addCookie(ck);// adding cookie in the response // creating submit button out.print("&lt;form action='servlet2' method='post'&gt;"); out.print("&lt;p&gt;Cookies已在浏览器中设置，现在跳转到第二个Servlet中读取Cookies的值。&lt;/p&gt;"); out.print("&lt;input type='submit' value='提交到第二个Servlet'&gt;"); out.print("&lt;/form&gt;"); out.close(); &#125; catch (Exception e) &#123; System.out.println(e); &#125; &#125;&#125; 文件：SecondServlet.java - 123456789101112131415161718192021222324252627282930313233343536373839404142package com.xq.Cookie;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet implementation class SecondServlet */@WebServlet("/SecondServlet")public class SecondServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public SecondServlet() &#123; super(); // TODO Auto-generated constructor stub &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; try &#123; response.setCharacterEncoding("UTF-8"); response.setContentType("text/html"); PrintWriter out = response.getWriter(); Cookie ck[] = request.getCookies(); out.print("Hello " + ck[0].getValue()); out.close(); &#125; catch (Exception e) &#123; System.out.println(e); &#125; &#125;&#125; 文件：web.xml - 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app &gt; &lt;display-name&gt;CookieServlet&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;FServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.xq.Cookie.FirstServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;FServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;SServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.xq.Cookie.SecondServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet2&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 在完成上面代码编写后，部署这个Web应用程序，打开浏览器访问URL： http://localhost:8080/CookieServlet ， 如是程序没有错误，应该会看到以下结果 - 提交后，看到以下界面 - 在第二个Servlet中读取的Cookies值如下 -]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Cookies</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet请求转发和重定向]]></title>
    <url>%2F2018%2F07%2F14%2FServlet%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%2F</url>
    <content type="text"><![CDATA[数据来源于网络，仅供平时查询使用 一、Servlet RequestDispatcher请求转发RequestDispatcher接口提供将请求转发送到另一个资源的功能，它可能是html，servlet或jsp等。 此接口也可用于包括另一资源的内容。它是servlet协作的一种方式，工作在服务器端。 在RequestDispatcher接口中定义了两种方法。它们分别是 ： 编号 方法 描述 1 public void forward(ServletRequest request,ServletResponse response)throws ServletException,java.io.IOException 将servlet的请求转发到服务器上的另一个资源(servlet，JSP文件或HTML文件)。 2 public void include(ServletRequest request,ServletResponse response)throws ServletException,java.io.IOException 在响应中包含资源的内容(servlet，JSP页面或HTML文件)。 如上图所示，第一个servlet转发请求到第二个servlet的响应发送给客户端。 第一个servlet的响应不会显示给用户。 如上图所示，第二个servlet的响应将包含在发送给客户端的第一个servlet的响应中。 二、Servlet 重定向HttpServletResponse接口的sendRedirect()方法可以用于将响应重定向到另一个资源，资源可能是servlet，jsp或html文件。它接受相对和绝对URL。 它在客户端工作，因为它使用浏览器的URL栏来发出另一个请求。 所以，它可以在服务器内部和外部工作。 三、forward()和sendRedirect()方法的区别RequestDispatcher的forward()方法和HttpServletResponse接口的sendRedirect()方法之间存在很多差异。如下面给出： forward()方法 sendRedirect()方法 forward()方法在服务器端工作。 sendRedirect()方法在客户端工作 它将相同的请求和响应对象发送到另一个servlet。 他总是发送一个新的请求 他只能在服务器内工作 可以在服务器外工作 request.getRequestDispacher(&quot;servlet2&quot;).forward(request,response); response.sendRedirect(&quot;servlet2&quot;)]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>请求转发</tag>
        <tag>重定向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet身份验证过滤器]]></title>
    <url>%2F2018%2F07%2F13%2FServlet%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[数据来源于网络，仅供平时查询使用 Servlet身份验证过滤器可以在过滤器中执行身份认证。 在这里，我们将如何在过滤器类检查由用户提交的密码，如果给定密码为admin，它将把请求转发到WelcomeAdmin servlet，否则会显示错误消息。 使用过滤器验证用户的示例 下面来看看如何使用过滤器验证用户的简单示例。 在这个示例中创建了以下几个主要的代码文件： index.html - 首页 MyFilter.java - 过滤器，用于处理用户登录信息和跳转。 AdminServlet.java - 管理员的Servlet web.xml - 项目描述符和配置信息。 打开Eclipse，创建一个动态Web项目：Authentication ，其完整的目录结构如下所示 - 以下是这个项目中的几个主要的代码文件。 文件：index.html - 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Servlet身份验证过滤器&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div style="font-align:center;"&gt; &lt;form action="login" method="post"&gt; 用户名: &lt;input type="text" name="username" value="xiaoqi"/&gt;密码: &lt;input type="password" name="password"/&gt; &lt;input type="submit" value="登录"/&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 文件：MyFilter.java - 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.xq.Filter;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;public class MyFilter implements Filter&#123; @Override public void destroy() &#123; System.out.println("MyFilter.destory"); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; response.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charset=UTF-8"); request.setCharacterEncoding("UTF-8"); PrintWriter out = response.getWriter(); String password = request.getParameter("password"); if(password==null) &#123; password = ""; &#125; if(password.equals("admin")) &#123; chain.doFilter(request, response); &#125;else &#123; out.print("用户名或密码错误!"); RequestDispatcher rd = request.getRequestDispatcher("index.html"); rd.include(request, response); &#125; &#125; @Override public void init(FilterConfig arg0) throws ServletException &#123; // TODO Auto-generated method stub &#125;&#125; 文件：AdminServlet.java - 12345678910111213141516171819202122232425262728package com.xq.Filter;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class AdminServlet extends HttpServlet&#123; /** * */ private static final long serialVersionUID = 1L; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setCharacterEncoding("UTF-8"); resp.setContentType("text/html;charset=UTF-8"); req.setCharacterEncoding("UTF-8"); PrintWriter out = resp.getWriter(); out.print("欢迎来到ADMIN界面~~"); out.close(); &#125;&#125; 文件：web.xml - 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app &gt; &lt;display-name&gt;Authentication&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;AdminServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.xq.Filter.AdminServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;AdminServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/login&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;f1&lt;/filter-name&gt; &lt;filter-class&gt;com.xq.Filter.MyFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;f1&lt;/filter-name&gt; &lt;url-pattern&gt;/login&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 在编写上面代码后，部署此Web应用程序(在项目名称上点击右键-&gt;”Run On Server…”)，打开浏览器访问URL： http://localhost:8080/Authentication/ ，如果没有错误，应该会看到以下结果 - 输入密码：admin，然后提交表单登录，应该会看到以下结果 -]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>身份验证</tag>
        <tag>过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet生命周期]]></title>
    <url>%2F2018%2F07%2F13%2FServlet%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[数据来源于网络，仅供平时查询使用 Servlet的生命周期，主要分为一下几个步骤 加载Servlet类 创建Servlet类 调用Servlet类的init方法 调用Servlet的service方法 调用Servlet的destroy方法 如果Sevlet实例被创建，则Servlet处于新状态。调用init()方法后，Servlet进入就绪状态。在就绪状态下，servlet执行所有任务。当web容器调用destroy()方法时，它转移到结束状态。 加载Servlet类 类加载器负责加载servlet类。 当Web容器接收到servlet的第一个请求时，将加载servlet类。 创建Servlet实例 Web容器在加载servlet类之后创建一个servlet的实例。servlet实例在servlet生命周期中只创建一次。 调用init方法 Web容器在创建servlet实例后调用init方法一次。 init方法用于初始化servlet。 它是javax.servlet.Servlet接口的生命周期方法。init方法的语法如下： 12public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException 调用service方法 每当接收到servlet的请求时，Web容器都会调用service方法。如果servlet未初始化，则遵循上述前三个步骤，然后调用service方法。 如果servlet被初始化，它调用service方法。 请注意，servlet仅初始化一次。 Servlet接口的service方法的语法如下： 调用destroy方法 从服务中删除servlet实例之前，Web容器调用destroy方法。它使servlet有机会清理所有资源，例如内存，线程等。Servlet接口的destroy方法的语法如下： 1public void destroy()]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac连接使用JDBC]]></title>
    <url>%2F2018%2F07%2F11%2FMac%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Mac连接数据库1.安装好mysql和java，安装成功后打开系统偏好设置，下面会看到，mysql安装成功后打开命令行，输入mysql.server start即可打开数据库。 2.下载mysql的jar包，然后在工程里引入jar包，右键单击工程，buildPath—&gt;Configure BuildPath，选择右上角的Libraries。 . 3.数据包准备(下Navicat,网盘,提取密码:x6b6) ​ 3.1 在数据库test中创建Part表 123456789CREATE TABLE `Part` ( `partkey` int(11) NOT NULL, `name` varchar(55) COLLATE gbk_bin DEFAULT NULL, `mfgr` char(25) COLLATE gbk_bin DEFAULT NULL, `type` varchar(25) COLLATE gbk_bin DEFAULT NULL, `size` int(11) DEFAULT NULL, `retailprice` double DEFAULT NULL, PRIMARY KEY (`partkey`)) ​ 3.2 添加如下数据 partkey Name mfgr type size retailprice 1 螺旋桨 浙大 散 10 1000 2 推进器 海大 整 20 2000 3 船舶模拟驾驶舱 海大 整 30 4000 4 南航 航天 散 20 2000 5 螺旋剑 浙大 散 10 1000 6 推进器 海大 整 20 2000 4. JDBC的开发步骤 引入JDBC驱动器jar包 在程序中引入JDBC驱动器类 创建java程序跟数据库的连接 跟数据库交互:发送sql语句，接收数据库对sql语句的执行结果 解析执行结果 连接并读取数据库 数据库名称:test 数据包名称:Part 端口号:3306 用户名:root 密码:root 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import com.mysql.jdbc.Connection;import com.mysql.jdbc.Statement;public class Test6 &#123; static &#123; try &#123; Class.forName("com.mysql.jdbc.Driver"); &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public static Connection getConnection() throws SQLException &#123; return (Connection) DriverManager.getConnection("jdbc:mysql://localhost:3306/test?useSSL=false&amp;user=root&amp;password=XQ3720xq&amp;useUnicode=true&amp;characterEncoding=utf-8"); &#125; public static void free(Connection conn,Statement st,ResultSet rs) &#123; if(rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; if(st != null) &#123; try &#123; st.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; if(conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 5 增、删、改、查。（注意释放资源） 增加数据 12345678910111213141516171819//批量增加sql语句 public void insertBatch() throws SQLException &#123; Connection conn = Test6.getConnection(); conn.setAutoCommit(false);//禁止提交 String sql = "insert into Part values (?,?,?,?,?,?)"; PreparedStatement ps = (PreparedStatement)conn.prepareStatement(sql); for(int i=7;i&lt;=8;i++) &#123; ps.setInt(1,i); ps.setString(2, "船舶模拟驾驶舱"+i); ps.setString(3, "海大"+i); ps.setString(4, "整"+i); ps.setInt(5, 40); ps.setDouble(6, 3000.0); ps.addBatch(); &#125; ps.executeBatch(); conn.commit();//提交 Test6.free(conn, ps, null); &#125; ​ 运行结果: 删除数据 1234567891011121314//批量删除sql语句 public void deleteBatch() throws SQLException &#123; Connection conn = Test6.getConnection(); conn.setAutoCommit(false); String sql = "delete from Part where partkey = ?"; PreparedStatement ps = (PreparedStatement)conn.prepareStatement(sql); for(int i=7;i&lt;=9;i++) &#123; ps.setInt(1, i); ps.addBatch(); &#125; ps.executeBatch(); conn.commit(); Test6.free(conn, ps, null); &#125; ​ 运行结果: 修改数据 12345678910111213141516//批量修改sql语句 public void updateBatch() throws SQLException &#123; Connection conn = Test6.getConnection(); conn.setAutoCommit(false); String sql = "update Part set name =?where partkey=?"; PreparedStatement ps = (PreparedStatement)conn.prepareStatement(sql); for(int i=1;i&lt;=6;i++) &#123; ps.setString(1, "航天"+i); ps.setInt(2, i); ps.addBatch(); &#125; ps.executeBatch(); conn.commit(); Test6.free(conn, ps, null); &#125; ​ 运行结果: 查找数据 12345678910//查询sql语句 public void queryAll(String sql) throws SQLException &#123; Connection conn = Test6.getConnection(); Statement st = (Statement)conn.createStatement(); ResultSet rs = st.executeQuery(sql); while(rs.next()) &#123; System.out.println(rs.getString("name")); &#125; Test6.free(conn, st, rs); &#125; ​ 运行结果:]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA-HTML&CSS]]></title>
    <url>%2F2018%2F07%2F08%2FHTML%E5%92%8CCSS%2F</url>
    <content type="text"><![CDATA[数据来源于网络，仅供平时查询使用 一、HTML语言基本介绍1.基本结构&lt;html&gt;&lt;!--根标签--&gt; &lt;head&gt;&lt;!--网页头部（用于设计网页属性--&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;!--定义文本信息--&gt; &lt;title&gt;哈哈哈 &lt;!--网页的名字--&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 小琦 &lt;!--主题部分(编辑区网页显示的内容部分)--&gt; &lt;/body&gt; &lt;/html&gt; 2.网页的基本标签元素 Tag Meaning &lt;h1&gt;&lt;/h1&gt; 标题标签 &lt;p&gt;&lt;/p&gt; 段落标签 &lt;em&gt;&lt;/em&gt; 斜体标签 &lt;br/&gt; 换行标签 &lt;hr/&gt; 水平线标签 &lt;strong&gt;&lt;/strong&gt; 加粗标签 &lt;blockquote&gt;&lt;/blockquote&gt; 段落缩进 &lt;font&gt;&lt;/font&gt; 字体标签(color、size、face) &lt;center&gt;&lt;/center&gt; 居中标签 &lt;sup&gt;&lt;/sup&gt; 上标 &lt;sub&gt;&lt;/sub&gt; 下标 &lt;pre&gt;&lt;pre&gt; 原样输出 3.注释和特殊符号 特殊符号 注释 &amp;nbsp; 空格(space) &amp;gt; 大于号(&gt;) &amp;lt; 小于号(&lt;) &amp;copy; 版权所有(©️) &amp;reg; 注册商标(®️) 4.超链接1)在同一页面下: (1)打锚点:&lt;a name=&quot;锚点名称&quot;&gt;&lt;/a&gt; (2)创建跳转链接:&lt;a href=&quot;锚点名称&quot;&gt;开始跳转&lt;/a&gt; 2)在不同的页面下: (1)打锚点:&lt;a name=&quot;锚点名称&quot;&gt;开始跳转&lt;/a&gt; (2)创建 跳转链接:&lt;a href=&quot;资源文件或者资源地址#锚点名称&quot;&gt;开始跳转&lt;/a&gt; 5.图片标签&lt;img src=&quot;图片路径&quot; alt=&quot;图片替代文本&quot; title=&quot;鼠标悬浮文字&quot; width=&quot;图片宽度&quot; height=&quot;图片高度&quot;/&gt; 6.列表标签无序号: &lt;ul type=&quot;circle&quot;&gt; &lt;li&gt;小琦&lt;/li&gt; &lt;li&gt;小猪&lt;/li&gt; &lt;/ul&gt; 有序号: &lt;ol type=&quot;circle&quot;&gt; &lt;li&gt;小琦&lt;/li&gt; &lt;li&gt;小猪&lt;/li&gt; &lt;/ol&gt; 7.块标签和行内标签&lt;div&gt;块标签&lt;/div&gt; &lt;span&gt;行标签&lt;/span&gt; 8.表格标签border || align || width || height 9.表单标签&lt;form action = &quot;#&quot; method = &quot;get/post&quot;&gt;&lt;/form&gt; form标签属性:1) action:整个表单提交的位置(可以使一个页面，也可以是JAVA代码) 2) method:表单提交的方式(get/post/delete…) post&lt;ul type=&quot;circle&quot;&gt; &lt;li&gt;不会将信息展示到地址栏&lt;/li&gt; &lt;li&gt;提交文件大小无限制&lt;/li&gt; &lt;/ul&gt; get&lt;ul type=&quot;circle&quot;&gt; &lt;li&gt;将用户信息展示到地址栏&lt;/li&gt; &lt;li&gt;提交文件大小无限制&lt;/li&gt; &lt;/ul&gt; 二、CSS介绍 1.CSS指层叠样式表。 2.样式定义如何显示HTML元素。 3.样式通常存储在样式表中。 4.把样式添加到HTML4.0中是为了解决内容与表现分离问题。 5.外部样式表可以极大的提高工作效率。 6.外部样式表通常存储在CSS文件中。 7.多个样式表可以层叠。 10.CSS的三种引入方式 第一种:行内引入 &lt;div style=&quot;color: red; font-size: 100px;&quot;&gt;程序猿&lt;/div&gt; 第二种:内部引入 &lt;style type=&quot;text/css&quot;&gt; .box{ color:red; font-size: 100px; } &lt;/style&gt; &lt;div class=&quot;box&quot;&gt;程序猿&lt;/div&gt; 第三种:外部引入 &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; herf=&quot;../css/style.css&quot;&gt; 11.CSS选择器CSS选择器有三种(元素选择器、类选择器、id选择器) 元素选择器 元素名{ 属性名：属性值; } id选择器 #id属性名{ 属性名：属性值; } 类选择器 .类选择器{ 属性名：属性值; } 12.CSS常用的属性(1)CSS文本 color: line-height: letter-spacing: text-align: word-spacing: (2)CSS字体 font-family:字体系列(类型) font-size:字体尺寸 font-style:字体的样式 normal:标准的字体样式 italic:斜体 font-wight:设置字体的粗细 CSS字体的简写属性: font:italic bold 36px &quot;黑体&quot; ; (3)CSS列表 list-style-type:设置列表项前面的类型 list-style-image：常用的属性值:URL 图像的路径 (4)CSS背景 background-image: background-repeat: background-position: background-color: (5)CSS表格 border-collapse :collapse; 合并边框 (6)CSS边框 border-style（上、右、下、左） border-width（上、右、下、左） border-color（上、右、下、左） 13.CSS让块元素成为内联元素display: inline-block 14.div居中margin: 0 auto; 15.块元素内容居中text-align: center;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员必备软件(持续更新中...)]]></title>
    <url>%2F2018%2F03%2F17%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言程序员的任务就是开发，那开发自然少不了一些软件的帮助，那么有哪些软件是开发必须的或者是一定程度上提高开发效率的呢？ 接下来就会介绍一下我自己电脑上必备的软件和使用教程(有些自己写的，也有是别人写的)。本篇文章主要针对 Mac 的用户，当然介绍的软件也有 windows 版本，就麻烦看客自行上网搜索吧。 先展示一下我电脑上的软件截图： 或许你也有相同的软件，那么就请你忽略这些。上面的软件大部分我都有安装包，如果有需要的请私聊我获取软件的资源，毕竟一些破解的不方便给出，还请见谅。 提高效率软件Typora 一款集 编辑预览 于一身的 MarkDown 编辑器，界面简洁，功能强大，操作简单。 教程入口 iPic Mac 上非常好用的图床神器，配合着 Typora 可以大大提高写博客的效率。 Windows 上有对应的 MPic。 教程入口 LICEcap 一款 操作简单、功能强大、性能卓越 的屏幕 GIF 录制工具软件。 教程入口 必备软件Android Studio 这可是吃饭的软件，我是一名 Android 程序的开发者，自然少不了。 教程入口 Intellij IDEA 这个一般作为我巩固 Java 基础或是学习后端的软件。 教程入口1 教程入口2 PyCharm Python 的开发工具。 教程入口 网易云音乐 这个不用多说吧，程序员和音乐更配哦，最近网易云不少音乐的版权要了回来，更加的爱它了。 Latern 额…你懂得，输入我的邀请码 57QP4H 来获得三个月的蓝灯专业版！立即下载 。不需要的可以忽视。 未完待续…]]></content>
      <categories>
        <category>程序员必备软件</category>
      </categories>
      <tags>
        <tag>工具软件</tag>
        <tag>提高效率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git-命令小结]]></title>
    <url>%2F2017%2F10%2F10%2FGit-%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[数据来源于网络，仅供平时查询使用 一、新建代码库// 在当前目录新建一个 Git 代码库 git init // 新建一个目录，将其初始化为 Git 代码库 git init [project-name] // 下载一个项目 git clone [project-url] 二、基础配置// 显示当前所有的 Git 配置 git config --list // 编辑 Git 配置文件 git config -e [--global] // 设置提交代码时的用户信息 git config [--global] user.name &quot;[name]&quot; git config [--global] user.email &quot;[email]&quot; 三、增加/删除文件// 添加文件到暂存区 git add [file] [file1] ... // 添加指定目录到暂存区，包括子目录 git add [dir] // 添加当前目录的所有文件到暂存区 git add . // 添加每个变化钱，都会要求确认 // 对于同一个文件的多出变化，可以实现分次提交 git add -p // 删除工作区文件，并且将这次删除放入暂存区 git rm [file1] [file2] ... // 停止追踪指定文件，但该文件会保留在工作区 git rm --cached [file] // 改名文件，并且将这个改名放入暂存区 git mv [file-original] [file-renamed] 四、代码提交// 提交暂存区到仓库区 git commit -m &quot;[message]&quot; // 提交暂存区指定的文件到仓库区 git commit [file1] [file2] ... -m [message] // 提交工作区自上次 commit 之后的变化，直接到仓库区 git commit -a // 提交时显示所有 diff 信息 git commit -b // 使用一次新的 commit，替代上一次提交 git commit --amend -m &quot;[message]&quot; // 重新上一次的 commit，并包括之id那个文件的新变化 git commit --amend [file1] [file2] ... 五、分支// 列出所有本地的分支 git branch // 列出所有远程的分支 git branch -r // 列出所有本地分支和远程分支 git branch -a // 新建一个分支，但依然停留在当前的分支 git branch [branch_name] // 新建一个分支，并且切换到该分支 git checkout -b [branch_name] // 新建一个分支，指向指定的 commit git branch [branch_name] [commit] // 新建一个分支，与指定的远程分支建立追踪关系 git branch --track [branch_name] [remote_branch] // 切换到指定的分支，并更新工作区 git checkout [branch_name] // 切换到上一个分支 git checkout - // 建立追踪关系，在现有分支与指定的远程分支之间 git branch --set-upstream [branch_name] [remote_branch] // 合并指定分支到当前分支 git merge [branch_name] // 选择一个 commit，合并到当前的分支 git cherry-pick [commit] // 删除分支 git branch -d [branch_name] // 删除远程分支 git push origin --delete [branch_name] git branch -dr [remote/branch_name] 六、标签// 列出所有 tag git tag // 新建一个 tag 在当前的 commit git tag [tag] // 新建一个 tag 在指定的 commit git tab [tag] [commit] // 删除本地 tag git tag -d [tag] // 删除远程 tag git push orgin :refs/tags/[tag] // 查看 tag 信息 git show [tag] // 提交指定 tag 信息 git push [remote] [tag] // 提交所有 tag git push [remote] --tags // 新建一个分支，指向指定某个 tag git checkout -b [branch] [tag] 七、查看信息// 显示所有变更的文件 git status // 显示当前分支的版本历史 git log // 显示 commit 历史，以及每次 commit 发生的变更 git log --stat // 搜索提交历史，根据关键词 git log -S [keyword] // 显示某个 commit 之后所有的变动，每个 commit 占据一行 git log [tag] HEAD --pretty=format:%s // 显示某个文件的版本历史，包括文件名 git log --follow [file] git whatchanged [file] // 显示指定文件相关的每一次 diff git log -p [file] // 显示过去5次提交 git log -5 --pretty --oneline // 显示所有提交过的用户，按提交次数排序 git shortlog -sn // 显示指定文件是什么人在什么时候修改过 git blame [file] // 显示暂存区和工作区的差异 git diff // 显示暂存区和上一个 commit 的差异 git diff --cached [file] // 显示暂存区与当前分支最新 commit 之间的差异 git diff HEAD // 显示两次提交之间的差异 git diff [first_branch]...[second_branch] // 显示今天你写了多少行代码 git diff --shortstat &quot;@{0 day ago}&quot; // 显示某次提交的元数据和内容变化 git show [commit] // 显示某次提交发生变化的文件 git show --name-only [commit] // 显示某次提交时，某个文件的内容 git show [commit]:[fileName] // 显示当前分支的最近几次提交 git reflog 八、远程同步// 下载远程仓库的所有变动 git fetch [remote] // 显示所有远程仓库 git remote -v // 显示某个远程仓库的信息 git remote show [remote] // 增加一个新的远程仓库，并命名 git remote add [shortName] [url] // 取回远程仓库的变化，并与本地分支合并 git pull [remote] [branch] // 上传本地指定分支到远程仓库 git push [remote] --force // 推送所有分支到远程仓库 git push [remote] --all 九、撤销// 恢复暂存区的指定文件到工作区 git checkout [file] // 恢复某个 commit 的指定文件到暂存区和工作区 git checkout [commit] [file] // 恢复暂存区的所有文件到工作区 git checkout . // 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变 git reset [file] // 重置暂存区和工作区，与上一次的 commit 保持一致 git reset --hard // 重置当iqanefnzhi的指针为指定 commit，同时重置暂存区 git reset [commit] // 重置当前分支的HEAD为指定的 commit，同时重置暂存区和工作区 git reset --hard [commit] // 重置当前HEAD为指定的 commit，但保持暂存区和工作区不变 git rest --keep [commit] // 新建一个 commit，用来撤销指定的 commit // 后者的所有变化都将被前者抵消，并且应用到当前分支 git revert [commit] // 暂时将为提交的变化移除，稍后再移入 git stash git stash pop]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
